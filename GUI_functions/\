import tkinter as tk

from tkinter import *
from os import walk
import os
from os import listdir
from os.path import isfile, join
import pickle

# This script simply builds the sub-menu for all assembly programs.
# A scrollable window is generated
# When a program is selected then the universal depenecies sub-menu is open via select_depend.py
# Once the edits have been made to the universal depenecies sub-menu the user may update the task detials data structure via clicking the button: "Save and Update Settings"

class ScrollFrame(tk.Frame):
    def __init__(self, parent):
        super().__init__(parent) 

    
        self.canvas = tk.Canvas(self, borderwidth=0)          
        self.viewPort = tk.Frame(self.canvas)                     
        self.vsb = tk.Scrollbar(self, orient="vertical", command=self.canvas.yview) 
        self.canvas.configure(yscrollcommand=self.vsb.set)                          
        self.vsb.pack(side="right", fill="y")                                       
        self.canvas.pack(side="left", fill="both", expand=True)                     
        self.canvas.create_window((4,4), window=self.viewPort, anchor="nw",tags="self.viewPort")

        self.viewPort.bind("<Configure>", self.onFrameConfigure)           

    def onFrameConfigure(self, event):                                              
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))  



class menu_frame(tk.Frame):
    
    def __init__(self, root):

        tk.Frame.__init__(self, root)
        self.scrollFrame = ScrollFrame(self) # add a new scrollable frame.


        self.scrollFrame.pack(side="top", fill="both", expand=True)
    


        tk.Label(self.scrollFrame.viewPort, text="Python").grid(column=2, row=1)
        tk.Label(self.scrollFrame.viewPort, text="Fortran").grid(column=2, row=2)
        tk.Label(self.scrollFrame.viewPort, text="C").grid(column=2, row=3)
        tk.Label(self.scrollFrame.viewPort, text="C++").grid(column=2, row=4)
        tk.Label(self.scrollFrame.viewPort, text="Assembly").grid(column=2, row=5)
        tk.Label(self.scrollFrame.viewPort, text="Number of Cores in Processor").grid(column=2, row=6)

        py_name = tk.StringVar()
        py_nameEntered = ttk.Entry(self.scrollFrame.viewPort, width=12, textvariable=py_name)
        py_nameEntered.grid(column=1, row=1)


    def click_set_cpp(self):
        # This allows the user to enter a default execution command for all C++ scripts.
        cpp_Label.configure(text='C++ Executed with: $' + cpp_name.get())
        input_file= open("GUI_functions/Cluster_details.bin", "rb")
        machines = pickle.load(input_file)
        input_file.close()

        for i in range(len(machines)):

            if this_machine[1] == machines[i][1]:
                machines[i][5][3] = cpp_name.get()
                output_file= open("GUI_functions/Cluster_details.bin", "wb")
                pickle.dump(machines, output_file)
                output_file.close()
                break


    def add_remove(self, msg, chosen_programs):
        viable_add = True
        for i in range(len(chosen_programs)):
            if msg[0] == chosen_programs[i][0]:
                chosen_programs.remove(chosen_programs[i])
                viable_add = False
                break
        if (viable_add == True):
            output_file = open("GUI_functions/update.bin", "wb")
            pickle.dump(msg, output_file)
            output_file.close()
            os.system("python3 GUI_functions/select_depend.py")
            input_file = open("GUI_functions/update.bin", "rb")
            new_task = pickle.load(input_file)
            input_file.close()
            chosen_programs.append(new_task)
    
        
    def printMsg_kill(self, msg):
        input_file = open("GUI_functions/Tasks_details.bin", "rb")
        all_programs = pickle.load(input_file)
        input_file.close()

        for i in range(len(all_programs)):
            for j in range(len(msg)):
                if all_programs[i][0] == msg[j][0]:
                    all_programs[i] = msg[j]

        output_file = open("GUI_functions/Tasks_details.bin", "wb")
        pickle.dump(all_programs, output_file)
        output_file.close()
        print(all_programs)
        root.quit()
    

def subsystem_menu():
    input_file = open("GUI_functions/update.bin", "rb")
    this_machine = list(pickle.load(input_file))
    input_file.close()

    # Here the name and IP of the machine displayed as the title of this window.
    input_file.close()

    path = os.path.dirname(os.path.realpath(__file__))

    files = []
    # r=root, d=directories, f = files

    files = [f for f in listdir(path) if isfile(join(path, f))]


    for f in files:
        if ".swp" in f:
            files.remove(f)

    root=tk.Tk()
    root.title(str(this_machine[0])+"@"+this_machine[1])
    menu_frame(root).pack(side="top", fill="both", expand=True)
    root.mainloop()
